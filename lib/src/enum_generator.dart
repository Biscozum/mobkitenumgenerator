import 'package:analyzer/dart/constant/value.dart';
import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:build/build.dart';
import 'package:source_gen/source_gen.dart';

import 'package:mobkit_enum_generator/annotations.dart';

/// It is a GeneratorFotAnnotation type class that performs all Enum generate operations.
class EnumGenerator extends GeneratorForAnnotation<EnumSerializable> {
  @override
  List<String> generateForAnnotatedElement(
    Element element,
    ConstantReader annotation,
    BuildStep buildStep,
  ) {
    /// A warning is issued if the Annotation Enum is appended above an external type.
    if (element is! EnumElement) {
      throw InvalidGenerationSourceError(
        '`@EnumSerializable` can only be used on enum elements.',
        element: element,
      );
    }
    final value = generateEnumSource(element);
    return [
      if (value.isNotEmpty) value,
    ];
  }

  /// Writes the codes generated by the Builder to the '.g.dart' files created later.
  String generateEnumSource(EnumElement element) {
    var classBuffer = StringBuffer();
    String cpClassName = "_\$${element.name}";
    String cpEditedClassName = "${cpClassName}EnumMap";
    ElementAnnotation itemType = element.metadata.annotations.first;
    DartType? objectType = itemType.computeConstantValue()!.getField("e")!.toTypeValue();
    String typeStr = objectType!.isDartCoreInt ? "int" : "String";
    List<DartObject> nullList = [];

    /// To get explanation from enums, it is checked whether the entered list is full or empty.
    List<DartObject> descriptionList =
        itemType.computeConstantValue()!.getField("descriptionList")!.toListValue() ?? nullList;
    classBuffer.writeln("const Map<${element.name}, $typeStr>$cpEditedClassName = {");
    for (int i = 0; i < element.fields.length - 1; i++) {
      if (element.fields[i].metadata.annotations.isNotEmpty) {
        ElementAnnotation item = element.fields[i].metadata.annotations.first;
        DartObject? object = item.computeConstantValue();
        dynamic valueDynamic;
        if (object != null) {
          if (objectType.isDartCoreInt) {
            valueDynamic = object.getField("value")!.toIntValue();
            if (valueDynamic == null) {
              /// An error is thrown if a different type than the specified value type is detected.
              throw InvalidGenerationSourceError(
                'Specifying a int in '
                '@EnumSerializable'
                ' uses an String value in '
                '@EnumValue'
                '.',
                element: element,
              );
            }
            classBuffer.writeln("${element.name}.${element.fields[i].name} : $valueDynamic,");
          } else if (objectType.isDartCoreString) {
            valueDynamic = object.getField("value")!.toStringValue();
            if (valueDynamic == null) {
              /// An error is thrown if a different type than the specified value type is detected.
              throw InvalidGenerationSourceError(
                'Specifying a String in '
                '@EnumSerializable'
                ' uses an int value in '
                '@EnumValue'
                '.',
                element: element,
              );
            }
            if (valueDynamic.toString().isEmpty) {
              classBuffer.writeln("${element.name}.${element.fields[i].name} : ${'""'},");
            } else if (valueDynamic.toString().isNotEmpty) {
              classBuffer.writeln("${element.name}.${element.fields[i].name} : '$valueDynamic',");
            }
          }
        }
      } else if (element.fields[i].metadata.annotations.isEmpty) {
        classBuffer.writeln("${element.name}.${element.fields[i].name} : $i,");
      }
    }
    classBuffer.writeln("};");
    classBuffer.writeln("extension ${element.name}Extension on ${element.name} {");
    classBuffer.writeln("$typeStr toValue() {");
    classBuffer.writeln("return $cpEditedClassName[this]!;");
    classBuffer.writeln("}");
    classBuffer.writeln("}");

    classBuffer.writeln("${element.name}? ${cpClassName}FromValue($typeStr id){");
    classBuffer.writeln("return $cpEditedClassName.keys.any((element) => $cpEditedClassName[element] == id)");
    classBuffer.writeln("? $cpEditedClassName.keys.firstWhere((element) => $cpEditedClassName[element] == id)");
    classBuffer.writeln(": null;");
    classBuffer.writeln("}");

    classBuffer.writeln("${element.name}? ${cpClassName}FromJson(dynamic json){");
    classBuffer.writeln("if(json is $typeStr) {");
    classBuffer.writeln("return ${cpClassName}FromValue(json);");
    classBuffer.writeln("}");
    classBuffer.writeln("return null;");
    classBuffer.writeln("}");

    // If the list entered to get the description is full, the comments in the list are assigned to the corresponding enums.
    if (descriptionList.isNotEmpty) {
      classBuffer.writeln("extension ${element.name}DescriptionExtension on ${element.name} {");
      classBuffer.writeln("String toDescription() {");
      classBuffer.writeln("switch(this) {");
      for (int i = 0; i < element.fields.length - 1; i++) {
        if (element.fields[i].metadata.annotations.isNotEmpty) {
          ElementAnnotation item = element.fields[i].metadata.annotations.first;
          DartObject? object = item.computeConstantValue();
          dynamic valueDynamic;
          if (object != null) {
            valueDynamic =
                descriptionList.asMap().containsKey(i) ? descriptionList[i].toStringValue() : (i + 1).toString();
            classBuffer.writeln("case ${element.name}.${element.fields[i].name}:");
            classBuffer.writeln("return '$valueDynamic';");
          }
        } else if (element.fields[i].metadata.annotations.isEmpty) {
          classBuffer.writeln("case ${element.name}.${element.fields[i].name}:");
          classBuffer.writeln("return " "$i" ";");
        }
      }
      classBuffer.writeln("}");
      classBuffer.writeln("}");
      classBuffer.writeln("}");
    }

    return classBuffer.toString();
  }
}

/// Method does transform first letter a uppercase of the String or returns empty String
extension StringCasingExtension on String {
  String toCapitalized() => length > 0 ? substring(0, 1).toLowerCase() + substring(1, length) : '';
}
